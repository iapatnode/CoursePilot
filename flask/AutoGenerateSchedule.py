# Sam's algorithm


from flask import Flask, request, render_template, redirect, session, Response, jsonify
from flask_cors import CORS
import os
import re, json
from mysql.connector import connect, Error
from datetime import datetime

#Flask App Setup
app = Flask(__name__)
CORS(app)
app.config["SECRET_KEY"] = os.urandom(32)

#Settings for testing
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0

#Credentails for database connection
scriptdir = os.path.dirname(os.path.abspath(__file__))
with open(os.path.join(scriptdir, "config.json")) as text:
    config = json.load(text)

#Establishes connection to database
def connection():
    try:
        conn = connect(host=config.get('host'), user=config.get('username'), password=config.get('password'), database=config.get('database'))
        return conn
    except Error as error:
        print(error)
        
conn = connection()

class Student:
    def __init__(self, name, studentID, studentMajor):
        self.name = name
        self.studentID = studentID
        self.studentMajor = studentMajor


class Course:
    def __init__(self, courseCode, semesterAvail, courseName, creditHours, prerequisites, prerequisiteDepth):
        self.courseCode = courseCode
        self.semesterAvail = semesterAvail
        self.courseName = courseName
        self.creditHours = creditHours
        self.prerequisites = prerequisites
        self.prerequisiteDepth = prerequisiteDepth
    



def AutoGeneratedSchedule():
    semesterChosen = "fall"

    CoursesTaken = getTakenCourses()
    CoursesRequired = getRequiredCourses()


    # removal
    for courseRequired in CoursesRequired:
        for courseTaken in CoursesTaken:
            # if the user has already taken the course then remove it from required courses
            if (courseTaken.courseCode == courseRequired.courseCode):
                CoursesRequired.remove(courseRequired)
            # if the class is in a semester not in the semester chosen remove it from required courses
            elif (courseRequired.semesterAvail != semesterChosen):
                CoursesRequired.remove(courseRequired)

            # need to make sure that all prereqs have been met
            #for coursePrereqs in courseRequired.prerequisites:
            #    if (courseTaken == )
    
    #sorting
    # using insertion sort to sort the array of classes by prereq depth

    print(getPrereqDepth(CoursesRequired[50]))

    

    '''
    for i in range(1, len(CoursesRequired)):
        key = CoursesRequired[i]
        j = i - 1
        while j >= 0 and len(key.prerequisites) < len(CoursesRequired[j].prerequisites):
            CoursesRequired[j + 1] = CoursesRequired[j]
            j -= 1
        courseRequired[j+1] = key

    CourseSchedule = []
    totalHours = 0    
    for courseRequired in CoursesRequired:
        if (totalHours < 17):
            CourseSchedule.append(courseRequired)
    '''

    return []
    

def getPrereqDepth(course):
    prereqDepth = 0
    if (len(course.prerequisites) != 0):
        for prereq in course.prerequisites:
            prereqDepth += getPrereqDepth(prereq)
    else:
        prereqDepth += 1
    return prereqDepth



def getTakenCourses():
    cursor = conn.cursor()
    try:
        cursor.execute("SELECT Course.courseCode, Course.courseSemester, Course.courseName, Course.creditHours FROM Course JOIN StudentCourses ON Course.courseCode = StudentCourses.courseCode JOIN Student ON StudentCourses.email = Student.email;")

        info = cursor.fetchall()
        print(info)

        

        return info
    except error as error:
        print("Could not pull the data" + str(error))

def getRequiredCourses():
    cursor = conn.cursor()
    try:
        cursor.execute("select Course.courseCode, Course.courseSemester, Course.courseName, Course.creditHours, MajorMinor.degreeId from Course JOIN ReqCourses ON Course.courseCode = ReqCourses.courseCode JOIN MajorMinorRequirements ON ReqCourses.category = MajorMinorRequirements.category JOIN MajorMinor ON MajorMinorRequirements.degreeId = MajorMinor.degreeId WHERE MajorMinor.degreeId = 1 AND Course.courseCode NOT LIKE 'HUMA%' AND Course.courseCode NOT LIKE 'PHYE%' AND Course.courseCode NOT LIKE 'SSFT%' AND Course.courseCode NOT LIKE 'WRIT%';")

        info = cursor.fetchall()

        requiredCourses = []

        for val in info:
            newCourse = Course(val[0], val[1], val[2], val[3], [], 0)
            requiredCourses.append(newCourse)
        #print(requiredCourses)

        cursor.execute("SELECT * FROM Prerequisite WHERE prereqGroup = 1;")

        prereqs = cursor.fetchall()
        


        # add the prereqs to the user
        for prereq in prereqs:
            for course in requiredCourses:
                if course.courseCode == prereq[2]:
                    for secondCourse in requiredCourses:
                        if secondCourse.courseCode == prereq[1]:
                            course.prerequisites.append(secondCourse)
                    
                    #print(course.prerequisites)

        return requiredCourses

    except error as error:
        print("Could not pull the data" + str(error))

AutoGeneratedSchedule()


'''
@app.route("/api/MajorPage", methods=["GET"])
def get_majors():

    cursor = conn.cursor()
    major_array = []
    course_array = []


    cursor.execute(
            select ReqCourses.courseCode, ReqCourses.category, ReqCourses.catYear, Requirement.reqDetails, MajorMinor.degreeId, MajorMinor.degreeHrs FROM ReqCourses JOIN 
                Requirement on ReqCourses.catYear = Requirement.requirementYear AND ReqCourses.category = Requirement.category JOIN
                MajorMinorRequirements ON Requirement.requirementYear = MajorMinorRequirements.catYear AND Requirement.category = MajorMinorRequirements.category JOIN
                MajorMinor ON MajorMinorRequirements.degreeId = MajorMinor.degreeId AND MajorMinorRequirements.catYear = MajorMinor.reqYear WHERE isMinor = 0;
        ,)


    course_table = cursor.fetchall()
    # print(class_table)

    result_string = ""
    for row in course_table:
        course_dict = {
            "course_code": row[0],
            "major_category": row[1],
            "category_year": row[2],
            "requirement_details": row[3],
            "degree_id": row[4],
            "degree_hours": str(row[5])
        }
        
        '[, , , , , , , ]'
        course_array.append(course_dict)

        for item in row:
            print(row)
            #result_string += str(item)
        
        
    
    # return (result_string)
    # return (search_val)
    return {
        "major": json.dumps(course_array)
    }

#get_majors()

REMOVAL

    - run through all the courses not taken
        - if the user has not taken the prereqs then leave this course out
        - if the class is not offered in the semester the user has chosen leave this course out
        - if the class is in a requirement that has already been met

    
SORTING 
    - check for prerequisite depth 
        - Deeper the depth more value on that class
    - Which class has higher need
        - Senior project is worth more than 3D Games
    
    - Smaller but needed things also
        - Make sure user has a science at least once every two semesters
        - Make sure user has a HUMA course at least once every two semesters
        - Make sure user takes SOCIAL science before their 5th semester
        - If the user needs to take SSFT then take before 5th semester

    - Do not need to sort general electives

PRUNE
    Now we are left with a queue of classes with the highest weights first

    - Grab classes out of the queue one by one
        - Check for time conflicts, if the second class conflicts with the first don't use second
        - Assure variety, having at most 3 classes from the same core requirements

'''
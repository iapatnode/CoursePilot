#----------------------------------------------------------------------------------------
#                            AUTO GENERATE SCHEDULE ALGORITHM
#
# This algorithm will return a tailored schedule to the user based on the courses they
# have already taken and the ones they can take. The algoritm is weighted heavily on
# prerequisite depth, available times and the courses not taken by the user. 
#
# it runs in three seperate operations
# REMOVAL - remove all the courses the user has taken and the ones they cannot take
# SORT - sort the courses based on their weights
# APPEND - place the courses into a list that will be returned to the user as a schedule
#----------------------------------------------------------------------------------------


from flask import Flask, request, render_template, redirect, session, Response, jsonify
from flask_cors import CORS
import os
import re, json
from mysql.connector import connect, Error
from datetime import datetime

import uuid 
import sys
import re

sys.setrecursionlimit(10**6)

#Flask App Setup
app = Flask(__name__)
CORS(app)
app.config["SECRET_KEY"] = os.urandom(32)

#Settings for testing
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0

#Credentails for database connection
scriptdir = os.path.dirname(os.path.abspath(__file__))
with open(os.path.join(scriptdir, "config.json")) as text:
    config = json.load(text)

#Establishes connection to database
def connection():
    try:
        conn = connect(host=config.get('host'), user=config.get('username'), password=config.get('password'), database=config.get('database'))
        return conn
    except Error as error:
        print(error)
        
conn = connection()

# class structure for a student
class Student:
    def __init__(self, name, studentID, studentMajor):
        self.name = name
        self.studentID = studentID
        self.studentMajor = studentMajor

# class structure for a Course (which is different from a class - explained below)
class Course:
    def __init__(self, courseCode, semesterAvail, courseName, creditHours, prerequisites, prerequisiteDepth, courseSection, dayAvail, startTime, endTime):
        self.courseCode = courseCode
        self.semesterAvail = semesterAvail
        self.courseName = courseName
        self.creditHours = creditHours
        self.prerequisites = prerequisites
        self.prerequisiteDepth = prerequisiteDepth
        self.courseSection = courseSection
        self.dayAvail = dayAvail
        self.startTime = startTime
        self.endTime = endTime

'''
class structure for a Class
    Course and Class are different becuase a Course is unique... there is only one Course
    with a Class however there are multiple different sections, times, days avaiable for that
    Course. Thus the Class structure is here to keep account for that
'''
class Class:
    def __init__(self, courseCode=None, semesterAvail=None, timeAvail=None, dayAvail=None, courseSection=None, startTime=None, endTime=None):
        self.courseCode = courseCode
        self.semesterAvail = semesterAvail
        self.timeAvail = timeAvail
        self.dayAvail = dayAvail
        self.courseSection = courseSection
        self.startTime = startTime
        self.endTime = endTime
    

'''
----------------------------------------------------
                    AUTO GENERATION
----------------------------------------------------
This method is the actual algorithm in play. It will
make calls to other functions and use lists generated
by those functions but this is where the logic takes
place for the algorithm to function properly.

user_email - the email of the user
semester_selection - which semester to generate 
                     courses for
----------------------------------------------------
'''
def GetAutoGeneratedSchedule(user_email, semester_selection):
    # list of all the courses the user has already taken
    CoursesTaken = getTakenCourses(user_email)
    # list of all the courses that are required to be taken
    CoursesRequired = getRequiredCourses(user_email)
    # list of all the class times of the required courses
    ClassTimes = getRequiredClasses(CoursesRequired, semester_selection)

    # variable used to determine the year of the user
    creditHoursTaken = getCreditHours(CoursesTaken)
    
    
    for course in CoursesRequired:
        # complicated function to get the prerequisite depth of each course - see below for more detail
        getPrereqDepth(course, course.prerequisiteDepth)

    
    #------------------------------------------
    #                  REMOVAL
    #------------------------------------------

    for courseRequired in CoursesRequired[:]:
        # making sure the course required is in the right semester
        if (courseRequired.semesterAvail != semester_selection and courseRequired.semesterAvail != "both"):
            CoursesRequired.remove(courseRequired)
        # if the user has not taken any courses then any course with prereqs will be removed
        elif (len(CoursesTaken) == 0):
            if (len(courseRequired.prerequisites) != 0):
                CoursesRequired.remove(courseRequired)
        else:
            # variable used to determine if a course should be removed
            removeCourse = False
            for courseTaken in CoursesTaken:
                # if the course has already been taken remove it
                if (courseRequired.courseCode == courseTaken.courseCode):
                    removeCourse = True

            for prereq in courseRequired.prerequisites:
                # prereq size is used as a variable to check if all the prereqs have been taken
                prereqSize = 0
                for courseTaken in CoursesTaken:
                    # if the user has taken the prereq then increment the size
                    if (prereq.courseCode == courseTaken.courseCode):
                        prereqSize += 1
                # if the user hasn't taken the prereqs then remove the course
                if (prereqSize != len(courseRequired.prerequisites)):
                    removeCourse = True

            if (removeCourse == True):
                CoursesRequired.remove(courseRequired)

    # used for displaying the courses in the UI. Making the semester both assures it works with either semester
    for course in CoursesRequired:
        if (course.semesterAvail == "both"):
            course.semesterAvail = semester_selection

    #------------------------------------------
    #                   SORT
    #------------------------------------------
    # sort the courses by their prerequisites in decreasing order
    CoursesRequired.sort(reverse=True, key=sortValue)

    # the schedule that will be returned
    recommendedSchedule = []
    # list used to assure no class overlap
    takenTimes = []

    # used to make sure the user doesn't go over 17 credit hours and get overcharged
    creditHours = 0

    for course in CoursesRequired:
        # if there are no courses currently recommended
        if (len(recommendedSchedule) == 0):
            # checking to make sure the courses time isn't already taken (even though it is the first class)
            if (checkIfTimeAvail(course, ClassTimes, takenTimes) != False):
                # append the course
                recommendedSchedule.append(course)
                creditHours += course.creditHours
        else:
            # making sure there are no two duplicates
            # this should be handled with the Class times but this backs it up to assure no two courses are the same at all
            courseDuplicate = True
            # only one huma should be taken at a time
            oneHuma = True
            # this variable is used to see if the user can take level 300 and 400 courses
            canTakeHigher = True
            for recommendedCourse in recommendedSchedule[:]:
                # checking for a duplicate
                if (recommendedCourse.courseCode == course.courseCode):
                    courseDuplicate = False
                # assuring only one huma
                if (course.courseName[0:3] == "CIV" and recommendedCourse.courseName[0:3] == "CIV" or course.courseCode[0:4] == "HUMA" and recommendedCourse.courseCode[0:4] == "HUMA"):
                    oneHuma = False
                courseLevel = re.findall('\d+', course.courseCode)
                # assuring freshman and sophomores only take 100-200 level courses and seniors can take 300-400 courses
                if (courseLevel[0][:1] == '3' and creditHoursTaken < 30 or courseLevel[0][:1] == '4' and creditHoursTaken < 30):
                    canTakeHigher = False
            # if every check passes
            if (creditHours <= 12 and courseDuplicate == True and oneHuma == True and canTakeHigher == True):
                # if the time is available
                if (checkIfTimeAvail(course, ClassTimes, takenTimes) != False):
                    # add the course
                    recommendedSchedule.append(course)
                    creditHours += course.creditHours
            # reseting the variables
            courseDuplicate = True
            oneHuma = True
            canTakeHigher = True

    return recommendedSchedule
    
'''
----------------------------------------------
This function will return the number of credit
hours the user has taken
----------------------------------------------
CoursesTaken - the courses the user has taken
----------------------------------------------
'''
def getCreditHours(CoursesTaken):
    creditHoursTaken = 0
    for course in CoursesTaken:
        creditHoursTaken += course.creditHours
    return creditHoursTaken

'''
----------------------------------------------
This function checks if a course can be added
without overlap between courses
----------------------------------------------
course - the course in question to be added
ClassTimes - the classtimes of all the courses
takenTimes - the times of all the courses 
            already in the schedule
----------------------------------------------
'''
def checkIfTimeAvail(course, ClassTimes, takenTimes):
    for classTime in ClassTimes:
        # go to the course in question and get it's class times
        if (course.courseCode == classTime.courseCode):
            # if the user already has courses in the recommended schedule
            if (len(takenTimes) != 0):
                # variable to make sure the time is avaiable
                timeFree = True
                for takenTime in takenTimes[:]:
                    # if the timeavail is the same then don't add
                    if (classTime.timeAvail == takenTime.timeAvail):
                        timeFree = False
                    # if the starttime is between the taken time then don't add
                    elif (takenTime.startTime <= classTime.startTime and classTime.startTime <= takenTime.endTime):
                        timeFree = False
                    # if the endtime is between the taken time then don't add
                    elif (takenTime.startTime <= classTime.endTime and classTime.endTime <= takenTime.endTime):
                        timeFree = False
                # if ya can add the course
                if (timeFree == True):
                    # THEN ADD THE COURSE!
                    course.courseSection = classTime.courseSection
                    course.dayAvail = classTime.dayAvail
                    course.startTime = classTime.startTime
                    course.endTime = classTime.endTime
                    takenTimes.append(classTime)
                    return True
            else:
                # if it's the first course to be added then add it
                course.courseSection = classTime.courseSection
                course.dayAvail = classTime.dayAvail
                course.startTime = classTime.startTime
                course.endTime = classTime.endTime
                takenTimes.append(classTime)
                return True
    return False

'''
----------------------------
Used for sorting in reverse
----------------------------
'''
def sortValue(course):
    return course.prerequisiteDepth

'''
---------------------------------------------------
This function is a recursive function that will
return the prerequisite depth of each course.
Prereq depth is given by how many courses need
the course in question... I.E. COMP 141 is needed
by almost every computer science class, thus it
will have a massive prerequisite depth
---------------------------------------------------
course - the course to get prereq depth of
coursePrereqDepth - the current depth of the course
---------------------------------------------------
'''
def getPrereqDepth(course, coursePrereqDepth):
    # base case for the courses that have zero prereqs
    if (len(course.prerequisites) == 0):
        # the default coursePrereqDepth will be 0
        course.prerequisiteDepth = coursePrereqDepth
        return 0
    else:
        for prereq in course.prerequisites:
            # some courses have themselves as a prereq... 
            # this makes sure that wont result in an infinite loop
            if prereq.courseCode != course.courseCode:
                # set this courses prereq depth
                prereq.coursePrereqDepth = coursePrereqDepth
                # RECURSIVE FUNCTION!!!!
                getPrereqDepth(prereq, coursePrereqDepth + 1)
    return 0

'''
---------------------------------------------------
This function will get the courses the user has
already taken and assign them to a class structure
---------------------------------------------------
user_email - the users email
---------------------------------------------------
'''
def getTakenCourses(user_email):

    try:
        # getting all of the courses the user has taken
        cursor = conn.cursor()
        cursor.execute("select Course.courseCode, Course.courseSemester, Course.courseName, Course.creditHours from StudentCourses JOIN Course on StudentCourses.courseCode = Course.courseCode WHERE StudentCourses.email = %s;", (user_email,))
        info = cursor.fetchall()
        takenCourses = []

        for val in info:
            # creating a new course structure for each course recieved through the query
            newCourse = Course(val[0], val[1], val[2], val[3], [], 0, "", "", "", "")
            takenCourses.append(newCourse)

        return takenCourses
    except error as error:
        print("Could not pull the data" + str(error))

'''
---------------------------------------------------
This function will get the courses the user needs 
to take and assign them to a class structure
---------------------------------------------------
user_email - the users email
---------------------------------------------------
'''
def getRequiredCourses(user_email):
    
    try:
        # getting all of the required courses for the user's major
        cursor = conn.cursor()
        cursor.execute("select degreeId from StudentMajorMinor WHERE email = %s;", (user_email,))

        # we only want the first value from this query which is the degree ID
        degreeID = cursor.fetchall()[0]
        

        # getting the required courses for the user's major
        cursor.execute("select Course.courseCode, Course.courseSemester, Course.courseName, Course.creditHours from Course JOIN ReqCourses ON Course.courseCode = ReqCourses.courseCode JOIN MajorMinorRequirements ON ReqCourses.category = MajorMinorRequirements.category JOIN MajorMinor ON MajorMinorRequirements.degreeId = MajorMinor.degreeId WHERE MajorMinor.degreeId = %s", (degreeID))
        info = cursor.fetchall()
        requiredCourses = []

        for val in info:
            # if it is not the first course being created
            if (len(requiredCourses) != 0):
                # variable used to see if we should add a course
                addCourse = True
                # for loop to make sure duplicates don't occur
                for course in requiredCourses:
                    if (course.courseCode == val[0]):
                        addCourse = False
                if (addCourse == True):
                    # add the course!
                    newCourse = Course(val[0], val[1], val[2], val[3], [], 0, "x", "x", "", "")
                    requiredCourses.append(newCourse)
            # if it is the first course being created
            else:
                # add the course!
                newCourse = Course(val[0], val[1], val[2], val[3], [], 0, "x", "x", "", "")
                requiredCourses.append(newCourse)

        # get the prereqs for each of the courses
        cursor.execute("SELECT * FROM Prerequisite WHERE prereqGroup = 1;")
        prereqs = cursor.fetchall()
        
        # add the prereqs to each course
        for prereq in prereqs:
            for course in requiredCourses:
                if (course.courseCode == prereq[2]):
                    for secondCourse in requiredCourses:
                        if (secondCourse.courseCode == prereq[1]):
                            course.prerequisites.append(secondCourse)

        return requiredCourses

    except error as error:
        print("Could not pull the data" + str(error))


'''
---------------------------------------------------
This function will get the classes the user needs
to take and assign them to a class structure
---------------------------------------------------
user_email - the users email
---------------------------------------------------
'''
def getRequiredClasses(CoursesRequired, semester_selection):
    try:
        # get all of the times for each course
        cursor = conn.cursor()
        cursor.execute("select * FROM Class WHERE classSemester = %s;", (semester_selection,))
        info = cursor.fetchall()
        times = []

        for val in info:
            # assign them to a class structure
            newClass = Class(val[5], val[1], str(val[2]) + str(val[3]), val[4], val[0], val[2], val[3])
            times.append(newClass)
        

        # only return the times for the courses required
        classTimes = []
        for classTime in times:
            for course in CoursesRequired:
                if (classTime.courseCode == course.courseCode):
                    classTimes.append(classTime)

        return classTimes
    except error as error:
        print("Could not pull the data" + str(error))
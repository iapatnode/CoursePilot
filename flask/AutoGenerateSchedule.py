# Sam's algorithm


from flask import Flask, request, render_template, redirect, session, Response, jsonify
from flask_cors import CORS
import os
import re, json
from mysql.connector import connect, Error
from datetime import datetime

import uuid 
import sys

sys.setrecursionlimit(10**6)

#Flask App Setup
app = Flask(__name__)
CORS(app)
app.config["SECRET_KEY"] = os.urandom(32)

#Settings for testing
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0

#Credentails for database connection
scriptdir = os.path.dirname(os.path.abspath(__file__))
with open(os.path.join(scriptdir, "config.json")) as text:
    config = json.load(text)

#Establishes connection to database
def connection():
    try:
        conn = connect(host=config.get('host'), user=config.get('username'), password=config.get('password'), database=config.get('database'))
        return conn
    except Error as error:
        print(error)
        
conn = connection()

class Student:
    def __init__(self, name, studentID, studentMajor):
        self.name = name
        self.studentID = studentID
        self.studentMajor = studentMajor


class Course:
    def __init__(self, courseCode, semesterAvail, courseName, creditHours, prerequisites, prerequisiteDepth, timeAvail, dayAvail, courseSection):
        self.courseCode = courseCode
        self.semesterAvail = semesterAvail
        self.courseName = courseName
        self.creditHours = creditHours
        self.prerequisites = prerequisites
        self.prerequisiteDepth = prerequisiteDepth
        self.timeAvail = timeAvail
        self.dayAvail = dayAvail
        self.courseSection = courseSection
    




def GetAutoGeneratedSchedule(user_email):

    
    semesterChosen = "fall"

    CoursesTaken = getTakenCourses(user_email)
    CoursesRequired = getRequiredCourses(user_email)

    

    # removal
    for courseRequired in CoursesRequired[:]:
        
        if (courseRequired.semesterAvail != semesterChosen and courseRequired.semesterAvail != "both"):
            CoursesRequired.remove(courseRequired)
        elif (len(CoursesTaken) == 0):
            if (len(courseRequired.prerequisites)):
                CoursesRequired.remove(courseRequired)
        else:
            for courseTaken in CoursesTaken:
                # if the user has already taken the course then remove it from required courses
                if (courseTaken.courseCode == courseRequired.courseCode):
                    CoursesRequired.remove(courseRequired)
            
            for coursePrereq in courseRequired.prerequisites:
                preqLen = 0
                for courseTaken in CoursesTaken:
                    if (courseTaken == coursePrereq):
                        preqLen += 1
                if (preqLen != len(courseRequired.prerequisites)):
                    CoursesRequired.remove(courseRequired)
    

    for course in CoursesRequired:
        getPrereqDepth(course, course.prerequisiteDepth)

    CoursesRequired.sort(reverse=True, key=sortValue)

    recommendedSchedule = []


    creditHours = 0
    for course in CoursesRequired:
        if (len(recommendedSchedule) == 0):
            recommendedSchedule.append(course)
            creditHours += course.creditHours

        else:
            courseDuplicate = False
            timeConflict = False
            oneHuma = False
            for recommendedCourse in recommendedSchedule[:]:
                if (recommendedCourse.courseCode == course.courseCode):
                    courseDuplicate = True
                if (recommendedCourse.timeAvail == course.timeAvail and recommendedCourse.dayAvail == course.dayAvail):
                    timeConflict = True
                if (course.courseName[0:3] == "CIV" and recommendedCourse.courseName[0:3] == "CIV"):
                    oneHuma = True
                #print("working")
            if (creditHours <= 12 and courseDuplicate == False and timeConflict == False and oneHuma == False):
                recommendedSchedule.append(course)
                creditHours += course.creditHours
            courseDuplicate = False
            timeConflict = False
            oneHuma = False
                    
                #if (recommendedCourse.timeAvail != course.timeAvail and recommendedCourse.dayAvail != course.dayAvail and recommendedCourse.courseName != course.courseName and creditHours <= 12):

    return recommendedSchedule
    

def sortValue(course):
    return course.prerequisiteDepth

def getPrereqDepth(course, coursePrereqDepth):

    if (len(course.prerequisites) == 0):
        
        course.prerequisiteDepth = coursePrereqDepth
        return 0
    else:
        for prereq in course.prerequisites:
            prereq.coursePrereqDepth = coursePrereqDepth
            getPrereqDepth(prereq, coursePrereqDepth + 1)
    
    return 0
            




def getTakenCourses(user_email):
    cursor = conn.cursor()
    try:
        cursor.execute("SELECT Course.courseCode, Course.courseSemester, Course.courseName, Course.creditHours, Class.startTime, Class.endTime, Class.meetingDays, Class.courseSection FROM Course JOIN Class ON Course.courseCode = Class.courseCode JOIN StudentCourses ON Course.courseCode = StudentCourses.courseCode JOIN Student ON StudentCourses.email = Student.email WHERE Student.email = %s", (user_email))

        info = cursor.fetchall()
        

        takenCourses = []

        for val in info:
            newCourse = Course(val[0], val[1], val[2], val[3], [], 0, str(val[4]) + str(val[5]), val[6], val[7])
            takenCourses.append(newCourse)

        

        return takenCourses
    except error as error:
        print("Could not pull the data" + str(error))

def getRequiredCourses(user_email):
    
    try:
        cursor = conn.cursor()

        cursor.execute("select degreeId from StudentMajorMinor WHERE email = %s;", (user_email,))

        degreeID = cursor.fetchall()[0]
        

        #AND Course.courseCode NOT LIKE 'HUMA%' AND Course.courseCode NOT LIKE 'PHYE%' AND Course.courseCode NOT LIKE 'SSFT%' AND Course.courseCode NOT LIKE 'WRIT%'
        cursor.execute("select Course.courseCode, Class.classSemester, Course.courseName, Course.creditHours, Class.startTime, Class.endTime, Class.meetingDays, Class.courseSection from Course JOIN Class ON Course.courseCode = Class.courseCode JOIN ReqCourses ON Class.courseCode = ReqCourses.courseCode JOIN MajorMinorRequirements ON ReqCourses.category = MajorMinorRequirements.category JOIN MajorMinor ON MajorMinorRequirements.degreeId = MajorMinor.degreeId WHERE MajorMinor.degreeId = %s", (degreeID))

        info = cursor.fetchall()


        requiredCourses = []

        for val in info:
            newCourse = Course(val[0], val[1], val[2], val[3], [], 0, str(val[4]) + str(val[5]), val[6], val[7])
            requiredCourses.append(newCourse)
        


        # get the prereqs for each of the courses
        cursor.execute("SELECT * FROM Prerequisite WHERE prereqGroup = 1;")

        prereqs = cursor.fetchall()
        


        # add the prereqs to the user
        for prereq in prereqs:
            for course in requiredCourses:
                if course.courseCode == prereq[2]:
                    for secondCourse in requiredCourses:
                        if secondCourse.courseCode == prereq[1]:
                            course.prerequisites.append(secondCourse)
                    
                    #print(course.prerequisites)

        return requiredCourses

    except error as error:
        print("Could not pull the data" + str(error))




getTakenCourses("dybasjt17@gcc.edu")

'''
@app.route("/api/MajorPage", methods=["GET"])
def get_majors():

    cursor = conn.cursor()
    major_array = []
    course_array = []


    cursor.execute(
            select ReqCourses.courseCode, ReqCourses.category, ReqCourses.catYear, Requirement.reqDetails, MajorMinor.degreeId, MajorMinor.degreeHrs FROM ReqCourses JOIN 
                Requirement on ReqCourses.catYear = Requirement.requirementYear AND ReqCourses.category = Requirement.category JOIN
                MajorMinorRequirements ON Requirement.requirementYear = MajorMinorRequirements.catYear AND Requirement.category = MajorMinorRequirements.category JOIN
                MajorMinor ON MajorMinorRequirements.degreeId = MajorMinor.degreeId AND MajorMinorRequirements.catYear = MajorMinor.reqYear WHERE isMinor = 0;
        ,)


    course_table = cursor.fetchall()
    # print(class_table)

    result_string = ""
    for row in course_table:
        course_dict = {
            "course_code": row[0],
            "major_category": row[1],
            "category_year": row[2],
            "requirement_details": row[3],
            "degree_id": row[4],
            "degree_hours": str(row[5])
        }
        
        '[, , , , , , , ]'
        course_array.append(course_dict)

        for item in row:
            print(row)
            #result_string += str(item)
        
        
    
    # return (result_string)
    # return (search_val)
    return {
        "major": json.dumps(course_array)
    }

#get_majors()

REMOVAL

    - run through all the courses not taken
        - if the user has not taken the prereqs then leave this course out
        - if the class is not offered in the semester the user has chosen leave this course out
        - if the class is in a requirement that has already been met

    
SORTING 
    - check for prerequisite depth 
        - Deeper the depth more value on that class
    - Which class has higher need
        - Senior project is worth more than 3D Games
    
    - Smaller but needed things also
        - Make sure user has a science at least once every two semesters
        - Make sure user has a HUMA course at least once every two semesters
        - Make sure user takes SOCIAL science before their 5th semester
        - If the user needs to take SSFT then take before 5th semester

    - Do not need to sort general electives

PRUNE
    Now we are left with a queue of classes with the highest weights first

    - Grab classes out of the queue one by one
        - Check for time conflicts, if the second class conflicts with the first don't use second
        - Assure variety, having at most 3 classes from the same core requirements

'''
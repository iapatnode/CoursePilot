# Sam's algorithm


from flask import Flask, request, render_template, redirect, session, Response, jsonify
from flask_cors import CORS
import os
import re, json
from mysql.connector import connect, Error
from datetime import datetime

import uuid 
import sys
import re

sys.setrecursionlimit(10**6)

#Flask App Setup
app = Flask(__name__)
CORS(app)
app.config["SECRET_KEY"] = os.urandom(32)

#Settings for testing
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0

#Credentails for database connection
scriptdir = os.path.dirname(os.path.abspath(__file__))
with open(os.path.join(scriptdir, "config.json")) as text:
    config = json.load(text)

#Establishes connection to database
def connection():
    try:
        conn = connect(host=config.get('host'), user=config.get('username'), password=config.get('password'), database=config.get('database'))
        return conn
    except Error as error:
        print(error)
        
conn = connection()

class Student:
    def __init__(self, name, studentID, studentMajor):
        self.name = name
        self.studentID = studentID
        self.studentMajor = studentMajor


class Course:
    def __init__(self, courseCode, semesterAvail, courseName, creditHours, prerequisites, prerequisiteDepth, courseSection, dayAvail):
        self.courseCode = courseCode
        self.semesterAvail = semesterAvail
        self.courseName = courseName
        self.creditHours = creditHours
        self.prerequisites = prerequisites
        self.prerequisiteDepth = prerequisiteDepth
        self.courseSection = courseSection
        self.dayAvail = dayAvail

class Class:
    def __init__(self, courseCode=None, semesterAvail=None, timeAvail=None, dayAvail=None, courseSection=None):
        self.courseCode = courseCode
        self.semesterAvail = semesterAvail
        self.timeAvail = timeAvail
        self.dayAvail = dayAvail
        self.courseSection = courseSection
    


def GetAutoGeneratedSchedule(user_email, semester_selection):

    CoursesTaken = getTakenCourses(user_email)
    CoursesRequired = getRequiredCourses(user_email)
    ClassTimes = getRequiredClasses(CoursesRequired, semester_selection)

    

    creditHoursTaken = getCreditHours(CoursesTaken)
    print(creditHoursTaken)

    for course in CoursesRequired:
        getPrereqDepth(course, course.prerequisiteDepth)

    # removal method to take out any courses that cannot be taken
    #removeCourses(CoursesTaken, CoursesRequired, semester_selection)

    for courseRequired in CoursesRequired[:]:
        if (courseRequired.semesterAvail != semester_selection and courseRequired.semesterAvail != "both"):
            CoursesRequired.remove(courseRequired)
        elif (len(CoursesTaken) == 0):
            if (len(courseRequired.prerequisites) != 0):
                CoursesRequired.remove(courseRequired)
        else:
            removeCourse = False
            for courseTaken in CoursesTaken:
                if (courseRequired.courseCode == courseTaken.courseCode):
                    removeCourse = True
                    #CoursesRequired.remove(courseRequired)

            for prereq in courseRequired.prerequisites:
                prereqSize = 0
                for courseTaken in CoursesTaken:
                    if (prereq.courseCode == courseTaken.courseCode):
                        prereqSize += 1
                if (prereqSize != len(courseRequired.prerequisites)):
                    removeCourse = True
                    #CoursesRequired.remove(courseRequired)

            if (removeCourse == True):
                CoursesRequired.remove(courseRequired)
        

    CoursesRequired.sort(reverse=True, key=sortValue)

    recommendedSchedule = []
    takenTimes = []


    creditHours = 0
    for course in CoursesRequired:
        if (len(recommendedSchedule) == 0):
            if (checkIfTimeAvail(course, ClassTimes, takenTimes) != False):
                recommendedSchedule.append(course)
                creditHours += course.creditHours
        else:
            courseDuplicate = True
            oneHuma = True
            canTakeHigher = True
            for recommendedCourse in recommendedSchedule[:]:
                if (recommendedCourse.courseCode == course.courseCode):
                    courseDuplicate = False
                #if (recommendedCourse.timeAvail == course.timeAvail and recommendedCourse.dayAvail == course.dayAvail):
                #    timeConflict = False
                if (course.courseName[0:3] == "CIV" and recommendedCourse.courseName[0:3] == "CIV" or course.courseCode[0:4] == "HUMA" and recommendedCourse.courseCode[0:4] == "HUMA"):
                    oneHuma = False
                courseLevel = re.findall('\d+', course.courseCode)
                #print(courseLevel[0])
                if (courseLevel[0][:1] == '3' and creditHoursTaken < 30 or courseLevel[0][:1] == '4' and creditHoursTaken < 30):
                    canTakeHigher = False
                #print("working")

            if (creditHours <= 12 and courseDuplicate == True and oneHuma == True and canTakeHigher == True):
                if (checkIfTimeAvail(course, ClassTimes, takenTimes) != False):
                    recommendedSchedule.append(course)
                    creditHours += course.creditHours

            courseDuplicate = True
            oneHuma = True
            canTakeHigher = True
                    
                #if (recommendedCourse.timeAvail != course.timeAvail and recommendedCourse.dayAvail != course.dayAvail and recommendedCourse.courseName != course.courseName and creditHours <= 12):
        
    for course in recommendedSchedule:
        print(course.courseCode)
        print(course.courseSection)
        print("")

    return recommendedSchedule
    
def getCreditHours(CoursesTaken):
    creditHoursTaken = 0
    for course in CoursesTaken:
        creditHoursTaken += course.creditHours
    return creditHoursTaken

def checkIfTimeAvail(course, ClassTimes, takenTimes):
    for classTime in ClassTimes:
        if (course.courseCode == classTime.courseCode):
            
            if (len(takenTimes) != 0):
                timeFree = True
                for takenTime in takenTimes[:]:
                    if (classTime.timeAvail == takenTime):
                        timeFree = False
                        #print(takenTimes[0])
                    
                if (timeFree == True):
                    #print(classTime.courseSection)
                    course.courseSection = classTime.courseSection
                    course.dayAvail = classTime.dayAvail
                    takenTimes.append(classTime.timeAvail)
                    return True
            else:
                course.courseSection = classTime.courseSection
                course.dayAvail = classTime.dayAvail
                takenTimes.append(classTime.timeAvail)
                return True
    return False


def sortValue(course):
    return course.prerequisiteDepth

def getPrereqDepth(course, coursePrereqDepth):



    if (len(course.prerequisites) == 0):
        course.prerequisiteDepth = coursePrereqDepth
        return 0
    else:
        for prereq in course.prerequisites:
            prereq.coursePrereqDepth = coursePrereqDepth
            getPrereqDepth(prereq, coursePrereqDepth + 1)
    
    return 0


def getTakenCourses(user_email):
    cursor = conn.cursor()
    try:
        cursor.execute("select Course.courseCode, Course.courseSemester, Course.courseName, Course.creditHours from StudentCourses JOIN Course on StudentCourses.courseCode = Course.courseCode WHERE StudentCourses.email = %s;", (user_email,))

        info = cursor.fetchall()
        

        takenCourses = []

        for val in info:
            newCourse = Course(val[0], val[1], val[2], val[3], [], 0, "", "")
            takenCourses.append(newCourse)

        

        return takenCourses
    except error as error:
        print("Could not pull the data" + str(error))

def getRequiredCourses(user_email):
    
    try:
        cursor = conn.cursor()

        cursor.execute("select degreeId from StudentMajorMinor WHERE email = %s;", (user_email,))

        degreeID = cursor.fetchall()[0]
        

        #AND Course.courseCode NOT LIKE 'HUMA%' AND Course.courseCode NOT LIKE 'PHYE%' AND Course.courseCode NOT LIKE 'SSFT%' AND Course.courseCode NOT LIKE 'WRIT%'
        cursor.execute("select Course.courseCode, Course.courseSemester, Course.courseName, Course.creditHours from Course JOIN ReqCourses ON Course.courseCode = ReqCourses.courseCode JOIN MajorMinorRequirements ON ReqCourses.category = MajorMinorRequirements.category JOIN MajorMinor ON MajorMinorRequirements.degreeId = MajorMinor.degreeId WHERE MajorMinor.degreeId = %s", (degreeID))

        info = cursor.fetchall()


        requiredCourses = []
        for val in info:
            if (len(requiredCourses) != 0):
                
                addCourse = True
                for course in requiredCourses:
                    if (course.courseCode == val[0]):
                        addCourse = False
                if (addCourse == True):
                    newCourse = Course(val[0], val[1], val[2], val[3], [], 0, "x", "x")
                    requiredCourses.append(newCourse)
            else:
                newCourse = Course(val[0], val[1], val[2], val[3], [], 0, "x", "x")
                requiredCourses.append(newCourse)

        # get the prereqs for each of the courses
        cursor.execute("SELECT * FROM Prerequisite WHERE prereqGroup = 1;")

        prereqs = cursor.fetchall()

        

        cursor.execute("SELECT * FROM Course")

        allInfo = cursor.fetchall()
        

        
        for prereq in prereqs:
            for course in requiredCourses:
                if (course.courseCode == prereq[2]):
                    for secondCourse in requiredCourses:
                        if (secondCourse.courseCode == prereq[1]):
                            course.prerequisites.append(secondCourse)

        # add the prereqs to the user
                            

        return requiredCourses

    except error as error:
        print("Could not pull the data" + str(error))



def getRequiredClasses(CoursesRequired, semester_selection):
    try:
        cursor = conn.cursor()
        cursor.execute("select * FROM Class WHERE classSemester = %s;", (semester_selection,))

        info = cursor.fetchall()

        times = []

        for val in info:
            newClass = Class(val[5], val[1], str(val[2]) + str(val[3]), val[4], val[0])
            times.append(newClass)
        

        classTimes = []
        for classTime in times:
            for course in CoursesRequired:
                if (classTime.courseCode == course.courseCode):
                    classTimes.append(classTime)

        return classTimes
    except error as error:
        print("Could not pull the data" + str(error))


'''
@app.route("/api/MajorPage", methods=["GET"])
def get_majors():

    cursor = conn.cursor()
    major_array = []
    course_array = []


    cursor.execute(
            select ReqCourses.courseCode, ReqCourses.category, ReqCourses.catYear, Requirement.reqDetails, MajorMinor.degreeId, MajorMinor.degreeHrs FROM ReqCourses JOIN 
                Requirement on ReqCourses.catYear = Requirement.requirementYear AND ReqCourses.category = Requirement.category JOIN
                MajorMinorRequirements ON Requirement.requirementYear = MajorMinorRequirements.catYear AND Requirement.category = MajorMinorRequirements.category JOIN
                MajorMinor ON MajorMinorRequirements.degreeId = MajorMinor.degreeId AND MajorMinorRequirements.catYear = MajorMinor.reqYear WHERE isMinor = 0;
        ,)


    course_table = cursor.fetchall()
    # print(class_table)

    result_string = ""
    for row in course_table:
        course_dict = {
            "course_code": row[0],
            "major_category": row[1],
            "category_year": row[2],
            "requirement_details": row[3],
            "degree_id": row[4],
            "degree_hours": str(row[5])
        }
        
        '[, , , , , , , ]'
        course_array.append(course_dict)

        for item in row:
            print(row)
            #result_string += str(item)
        
        
    
    # return (result_string)
    # return (search_val)
    return {
        "major": json.dumps(course_array)
    }

#get_majors()

REMOVAL

    - run through all the courses not taken
        - if the user has not taken the prereqs then leave this course out
        - if the class is not offered in the semester the user has chosen leave this course out
        - if the class is in a requirement that has already been met

    
SORTING 
    - check for prerequisite depth 
        - Deeper the depth more value on that class
    - Which class has higher need
        - Senior project is worth more than 3D Games
    
    - Smaller but needed things also
        - Make sure user has a science at least once every two semesters
        - Make sure user has a HUMA course at least once every two semesters
        - Make sure user takes SOCIAL science before their 5th semester
        - If the user needs to take SSFT then take before 5th semester

    - Do not need to sort general electives

PRUNE
    Now we are left with a queue of classes with the highest weights first

    - Grab classes out of the queue one by one
        - Check for time conflicts, if the second class conflicts with the first don't use second
        - Assure variety, having at most 3 classes from the same core requirements

'''